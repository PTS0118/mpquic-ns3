/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * scratch/mpquic360-sim.cc
 *
 * MPQUIC-Ns3 (mpquic-1.2) based prototype for 360 GOP-Tile-Frame task transmission.
 *
 * Modes:
 *   --mode=single : single-path QUIC baseline (no multipath)
 *   --mode=rr     : MPQUIC with ROUND_ROBIN scheduler
 *   --mode=ours   : MPQUIC with PRIORITY_LOAD scheduler (priority+load aware)
 *
 * Task source: CSV generated by scripts/make_tasks.py
 * Task format: taskId,g,t,k,sizeBytes,deadlineSec,priority,isRedundant,originTaskId,payloadPath,payloadOffset,payloadLen
 *
 * Sender reads payload slice bytes and sends on a dedicated QUIC stream per task.
 * Receiver reassembles per-task bytes and writes them back to recovered file at correct offsets (optional).
 *
 * Outputs:
 *   logs/<mode>/sender_tasks.csv
 *   logs/<mode>/receiver_tasks.csv
 *   logs/<mode>/path_stats.csv
 */

 #include "ns3/core-module.h"
 #include "ns3/network-module.h"
 #include "ns3/internet-module.h"
 #include "ns3/point-to-point-module.h"
 #include "ns3/applications-module.h"
 
 #include "ns3/quic-helper.h"
 #include "ns3/quic-client-helper.h"
 #include "ns3/quic-server-helper.h"
 #include "ns3/quic-socket-base.h"
 #include "ns3/mp-quic-scheduler.h"
 
 #include <fstream>
 #include <sstream>
 #include <unordered_map>
 #include <vector>
 #include <algorithm>
 #include <filesystem>
 #include <iomanip>
 
 using namespace ns3;
 
 // ---------------------- helpers ----------------------
 static std::string BaseName(const std::string& p){
   auto pos = p.find_last_of("/\\");
   return (pos==std::string::npos)? p : p.substr(pos+1);
 }
 
 static bool ReadFileBytes(const std::string& path, uint64_t offset, uint32_t len, std::vector<uint8_t>& out) {
   out.assign(len, 0);
   std::ifstream fin(path, std::ios::binary);
   if(!fin.good()) return false;
   fin.seekg((std::streamoff)offset, std::ios::beg);
   fin.read((char*)out.data(), (std::streamsize)len);
   return fin.gcount() == (std::streamsize)len;
 }
 
 static void WriteFileBytesAt(const std::string& path, uint64_t offset, const uint8_t* data, uint32_t len) {
   std::filesystem::create_directories(std::filesystem::path(path).parent_path());
   std::fstream f(path, std::ios::in | std::ios::out | std::ios::binary);
   if(!f.good()){
     f.open(path, std::ios::out | std::ios::binary);
     f.close();
     f.open(path, std::ios::in | std::ios::out | std::ios::binary);
   }
   f.seekp((std::streamoff)offset, std::ios::beg);
   f.write((const char*)data, (std::streamsize)len);
   f.close();
 }
 
 // ---------------------- Task ----------------------
 struct Task {
   uint32_t taskId=0;
   uint32_t g=0,t=0,k=0;
   uint32_t sizeBytes=0;
   double   deadlineSec=0.0;
   double   priority=0.0;
   bool     isRedundant=false;
   uint32_t originTaskId=0;
 
   std::string payloadPath;
   uint64_t payloadOffset=0;
   uint32_t payloadLen=0;
 };
 
 static std::vector<Task> LoadTasksFromCsv(const std::string& path) {
   std::vector<Task> tasks;
   std::ifstream fin(path);
   if(!fin.good()){
     NS_FATAL_ERROR("Cannot open tasks CSV: " << path);
   }
   std::string line;
   while(std::getline(fin,line)){
     if(line.empty()) continue;
     if(line[0]=='#') continue;
     if(line.find("taskId")!=std::string::npos) continue;
 
     std::stringstream ss(line);
     std::string tok;
     Task x{};
 
     std::getline(ss,tok,','); x.taskId=std::stoul(tok);
     std::getline(ss,tok,','); x.g=std::stoul(tok);
     std::getline(ss,tok,','); x.t=std::stoul(tok);
     std::getline(ss,tok,','); x.k=std::stoul(tok);
 
     std::getline(ss,tok,','); x.sizeBytes=std::stoul(tok);
     std::getline(ss,tok,','); x.deadlineSec=std::stod(tok);
     std::getline(ss,tok,','); x.priority=std::stod(tok);
 
     std::getline(ss,tok,','); x.isRedundant=(std::stoi(tok)!=0);
     std::getline(ss,tok,','); x.originTaskId=std::stoul(tok);
 
     std::getline(ss,tok,','); x.payloadPath=tok;
     std::getline(ss,tok,','); x.payloadOffset=std::stoull(tok);
     std::getline(ss,tok,','); x.payloadLen=std::stoul(tok);
 
     tasks.push_back(x);
   }
   return tasks;
 }
 
 // ---------------------- Sender Application ----------------------
 class MpQuic360Sender : public Application {
 public:
   void Configure(Ipv4Address serverBindIp,
                  Ipv4Address peerIp,
                  uint16_t port,
                  std::string tasksCsv,
                  std::string outDir,
                  std::string mode,
                  uint32_t chunkSize,
                  bool enableRecoveryWrite)
   {
     m_bindIp = serverBindIp;
     m_peerIp = peerIp;
     m_port = port;
     m_tasksCsv = std::move(tasksCsv);
     m_outDir = std::move(outDir);
     m_mode = std::move(mode);
     m_chunkSize = chunkSize;
     m_enableRecoveryWrite = enableRecoveryWrite;
   }
 
 private:
   void StartApplication() override {
     std::filesystem::create_directories(m_outDir);
 
     m_tasks = LoadTasksFromCsv(m_tasksCsv);
 
     // originals first, then redundant; within each, by priority desc
     std::stable_sort(m_tasks.begin(), m_tasks.end(), [](const Task& a,const Task& b){
       if(a.isRedundant != b.isRedundant) return a.isRedundant < b.isRedundant;
       return a.priority > b.priority;
     });
 
     // create QUIC socket
     m_sock = CreateObject<QuicSocket>();
     m_sock->SetNode(GetNode());
 
     // Bind to specific interface IP so that the first path uses that address pair
     m_sock->Bind(InetSocketAddress(m_bindIp, 0));
 
     // connect
     m_sock->Connect(InetSocketAddress(m_peerIp, m_port));
 
     // Enable / disable multipath by mode
     if (m_mode == "single") {
       m_sock->SetAttribute("EnableMultipath", BooleanValue(false));
     } else {
       m_sock->SetAttribute("EnableMultipath", BooleanValue(true));
     }
 
     // log files
     m_fSend.open(m_outDir + "/sender_tasks.csv", std::ios::out);
     m_fSend << "simTime,taskId,g,t,k,isRedundant,originTaskId,priority,deadlineSec,streamId,bytesSent\n";
 
     m_fPath.open(m_outDir + "/path_stats.csv", std::ios::out);
     m_fPath << "simTime,subflowId,lastRttMs,cWnd,bytesInFlight,availableWindow\n";
 
     // schedule periodic path stats sampling
     Simulator::Schedule(Seconds(0.05), &MpQuic360Sender::SamplePathStats, this);
 
     // start sending loop
     Simulator::Schedule(Seconds(0.10), &MpQuic360Sender::SendNextTask, this);
   }
 
   void StopApplication() override {
     if (m_fSend.is_open()) m_fSend.close();
     if (m_fPath.is_open()) m_fPath.close();
     if (m_sock) m_sock->Close();
   }
 
   void SamplePathStats() {
     if (!m_sock) return;
 
     Ptr<QuicSocketBase> base = DynamicCast<QuicSocketBase>(m_sock->GetSocketBase());
     if (base) {
       auto subflows = base->GetActiveSubflows();
       for (uint32_t i=0;i<subflows.size();i++){
         auto tcb = subflows[i]->m_tcb;
         double rttMs = tcb->m_lastRtt.Get().GetSeconds()*1000.0;
         uint32_t cwnd = tcb->m_cWnd.Get();
         uint32_t bif  = tcb->m_bytesInFlight.Get();
         uint32_t aw   = base->AvailableWindow(i);
         m_fPath << std::fixed << std::setprecision(6)
                 << Simulator::Now().GetSeconds() << ","
                 << i << "," << rttMs << ","
                 << cwnd << "," << bif << "," << aw
                 << "\n";
       }
     }
 
     Simulator::Schedule(Seconds(0.05), &MpQuic360Sender::SamplePathStats, this);
   }
 
   void SendNextTask() {
    if (!m_sock) return;
    if (m_idx >= m_tasks.size()) return;
  
    const Task& u = m_tasks[m_idx];
  
    // IMPORTANT: stable streamId mapping so receiver can map stream->task
    const uint64_t streamId = (uint64_t)u.taskId; // or u.taskId*4 if your impl requires even/uni streams
  
    Ptr<QuicSocketBase> base = DynamicCast<QuicSocketBase>(m_sock->GetSocketBase());
    if (!base) {
      NS_LOG_UNCOND("[ERR] QuicSocketBase is null");
      return;
    }
  
    // (1) set MP scheduler type by mode (global config is okay before sim start,
    //     but we keep it here to be explicit)
    if (m_mode == "ours") {
      Config::SetDefault("ns3::MpQuicScheduler::SchedulerType",
                         IntegerValue((int)MpQuicScheduler::PRIORITY_LOAD));
    } else if (m_mode == "rr") {
      Config::SetDefault("ns3::MpQuicScheduler::SchedulerType",
                         IntegerValue((int)MpQuicScheduler::ROUND_ROBIN));
    } else {
      // single path: still can keep MIN_RTT, but multipath disabled already
      Config::SetDefault("ns3::MpQuicScheduler::SchedulerType",
                         IntegerValue((int)MpQuicScheduler::MIN_RTT));
    }
  
    // (2) KEY FIX: write priority hint to THIS stream (no socket overwrite issue)
    base->SetStreamAppPriorityHint(streamId, u.priority);
  
    // (3) push bytes into this stream
    uint32_t remaining = u.sizeBytes;
    uint64_t fileOff = u.payloadOffset;
    uint32_t sentTotal = 0;
  
    while (remaining > 0) {
      uint32_t cs = std::min(m_chunkSize, remaining);
  
      std::vector<uint8_t> buf;
      if (!ReadFileBytes(u.payloadPath, fileOff, cs, buf)) {
        buf.assign(cs, 0);
      }
  
      Ptr<Packet> p = Create<Packet>(buf.data(), buf.size());
  
      // Send(packet, flags) where flags is streamId in this QUIC implementation
      int ret = base->Send(p, streamId);
      if (ret < 0) {
        NS_LOG_UNCOND("[WARN] base->Send failed, streamId=" << streamId);
        // still continue to keep experiment running
      }
  
      remaining -= cs;
      fileOff += cs;
      sentTotal += cs;
    }
  
    m_fSend << std::fixed << std::setprecision(6)
            << Simulator::Now().GetSeconds() << ","
            << u.taskId << "," << u.g << "," << u.t << "," << u.k << ","
            << (u.isRedundant?1:0) << "," << u.originTaskId << ","
            << u.priority << "," << u.deadlineSec << ","
            << streamId << "," << sentTotal
            << "\n";
  
    m_idx++;
    Simulator::Schedule(MilliSeconds(1), &MpQuic360Sender::SendNextTask, this);
  }
  
 
 private:
   Ipv4Address m_bindIp;
   Ipv4Address m_peerIp;
   uint16_t m_port=4433;
   std::string m_tasksCsv;
   std::string m_outDir;
   std::string m_mode="ours";
   uint32_t m_chunkSize=1200;
   bool m_enableRecoveryWrite=false;
 
   std::vector<Task> m_tasks;
   size_t m_idx=0;
 
   Ptr<QuicSocket> m_sock;
   uint32_t m_nextStreamId=0;
 
   std::ofstream m_fSend;
   std::ofstream m_fPath;
 };
 
 // ---------------------- Receiver Application ----------------------
 class MpQuic360Receiver : public Application {
 public:
   void Configure(Ipv4Address bindIp,
                  uint16_t port,
                  std::string tasksCsv,
                  std::string outDir,
                  std::string recoverDir,
                  bool writeRecovered)
   {
     m_bindIp = bindIp;
     m_port = port;
     m_tasksCsv = std::move(tasksCsv);
     m_outDir = std::move(outDir);
     m_recoverDir = std::move(recoverDir);
     m_writeRecovered = writeRecovered;
   }
 
 private:
   struct Meta {
     uint32_t g,t,k;
     double deadline;
     double priority;
     bool isRed;
     uint32_t originId;
     std::string payloadPath;
     uint64_t payloadOffset;
     uint32_t payloadLen;
     uint32_t sizeBytes;
   };
   struct Prog {
     uint32_t got=0;
     double firstRx=-1;
     double lastRx=-1;
     bool done=false;
     bool miss=false;
   };
 
   void StartApplication() override {
     std::filesystem::create_directories(m_outDir);
     std::filesystem::create_directories(m_recoverDir);
 
     // load meta map by taskId
     auto tasks = LoadTasksFromCsv(m_tasksCsv);
     for (auto &t: tasks) {
       Meta m;
       m.g=t.g; m.t=t.t; m.k=t.k;
       m.deadline=t.deadlineSec;
       m.priority=t.priority;
       m.isRed=t.isRedundant;
       m.originId=t.originTaskId;
       m.payloadPath=t.payloadPath;
       m.payloadOffset=t.payloadOffset;
       m.payloadLen=t.payloadLen;
       m.sizeBytes=t.sizeBytes;
       m_meta[t.taskId]=m;
     }
 
     // create QUIC server
     m_srv = CreateObject<QuicServer>();
     m_srv->SetNode(GetNode());
     m_srv->Bind(InetSocketAddress(m_bindIp, m_port));
     m_srv->SetRecvCallback(MakeCallback(&MpQuic360Receiver::OnStreamData, this));
 
     m_fRecv.open(m_outDir + "/receiver_tasks.csv", std::ios::out);
     m_fRecv << "simTime,taskId,g,t,k,isRedundant,originTaskId,priority,deadlineSec,streamId,bytesRx,totalBytes,completed,deadlineMiss,firstRx,lastRx\n";
   }
 
   void StopApplication() override {
     if (m_fRecv.is_open()) m_fRecv.close();
     if (m_srv) m_srv->Close();
   }
 
   void OnStreamData(uint32_t streamId, Ptr<Packet> pkt) {
     double now = Simulator::Now().GetSeconds();
     uint32_t n = pkt->GetSize();
 
     // streamId -> taskId mapping:
     // here we assume sender uses streamId = 0,4,8,... in task order, so receiver reconstructs order by arrival.
     // For correctness, we embed taskId into streamId in a stable way:
     //   sender: streamId = taskId*4
     // In case you want strictness, just change sender line to "streamId = u.taskId * 4".
     uint32_t taskId = streamId / 4;
 
     auto it = m_meta.find(taskId);
     if (it == m_meta.end()) {
       return;
     }
     const Meta &m = it->second;
 
     Prog &p = m_prog[taskId];
     if (p.firstRx < 0) p.firstRx = now;
     p.lastRx = now;
     p.got += n;
 
     if (!p.done && p.got >= m.sizeBytes) {
       p.done = true;
       p.miss = (now > m.deadline);
     }
 
     // (optional) write recovered bytes to file:
     // NOTE: QUIC delivers stream bytes in-order; packet boundary != byte boundary.
     // For this verification prototype we still write "as arrived" sequentially into slice region.
     if (m_writeRecovered && (!m.isRed)) {
       std::vector<uint8_t> buf(n);
       pkt->CopyData(buf.data(), n);
       // we write sequentially: offset = payloadOffset + (p.got-n)
       uint64_t off = m.payloadOffset + (uint64_t)(p.got - n);
       std::string outFile = m_recoverDir + "/" + BaseName(m.payloadPath);
       WriteFileBytesAt(outFile, off, buf.data(), n);
     }
 
     m_fRecv << std::fixed << std::setprecision(6)
             << now << ","
             << taskId << ","
             << m.g << "," << m.t << "," << m.k << ","
             << (m.isRed?1:0) << ","
             << m.originId << ","
             << m.priority << ","
             << m.deadline << ","
             << streamId << ","
             << n << ","
             << m.sizeBytes << ","
             << (p.done?1:0) << ","
             << (p.miss?1:0) << ","
             << p.firstRx << ","
             << p.lastRx
             << "\n";
   }
 
 private:
   Ipv4Address m_bindIp;
   uint16_t m_port=4433;
   std::string m_tasksCsv;
   std::string m_outDir;
   std::string m_recoverDir;
   bool m_writeRecovered=false;
 
   Ptr<QuicServer> m_srv;
   std::ofstream m_fRecv;
 
   std::unordered_map<uint32_t, Meta> m_meta;
   std::unordered_map<uint32_t, Prog> m_prog;
 };
 
 // ---------------------- Main ----------------------
 int main(int argc, char *argv[])
 {
   std::string mode="ours"; // single|rr|ours
 
   std::string rate0="50Mbps", rate1="20Mbps";
   std::string delay0="20ms",  delay1="60ms";
   double loss0=0.001, loss1=0.02;
 
   double simTime=20.0;
 
   std::string tasksCsv="data/tasks/tasks.csv";
   std::string outBase="logs";
   std::string recoverBase="data/recovered";
   bool writeRecovered=false;
 
   uint32_t chunkSize=1200;
 
   CommandLine cmd;
   cmd.AddValue("mode", "single|rr|ours", mode);
   cmd.AddValue("rate0", "Path0 rate", rate0);
   cmd.AddValue("rate1", "Path1 rate", rate1);
   cmd.AddValue("delay0","Path0 delay", delay0);
   cmd.AddValue("delay1","Path1 delay", delay1);
   cmd.AddValue("loss0","Path0 loss", loss0);
   cmd.AddValue("loss1","Path1 loss", loss1);
   cmd.AddValue("simTime","Simulation time", simTime);
 
   cmd.AddValue("tasksCsv","Tasks CSV path", tasksCsv);
   cmd.AddValue("outBase","Output base dir", outBase);
   cmd.AddValue("recoverBase","Recovered output base dir", recoverBase);
   cmd.AddValue("writeRecovered","Write recovered bytes for original tasks", writeRecovered);
 
   cmd.AddValue("chunkSize","Chunk size per SendOnStream", chunkSize);
   cmd.Parse(argc, argv);
 
   std::string outDir = outBase + "/" + mode;
   std::string recoverDir = recoverBase + "/" + mode;
 
   NS_LOG_UNCOND("mpquic360-sim START mode="<<mode);
   NS_LOG_UNCOND(" tasksCsv="<<tasksCsv);
   NS_LOG_UNCOND(" outDir="<<outDir);
 
   NodeContainer nodes;
   nodes.Create(2); // 0 sender, 1 receiver
 
   PointToPointHelper p2p0, p2p1;
   p2p0.SetDeviceAttribute("DataRate", StringValue(rate0));
   p2p0.SetChannelAttribute("Delay", StringValue(delay0));
   p2p1.SetDeviceAttribute("DataRate", StringValue(rate1));
   p2p1.SetChannelAttribute("Delay", StringValue(delay1));
 
   NetDeviceContainer dev0 = p2p0.Install(nodes.Get(0), nodes.Get(1));
   NetDeviceContainer dev1 = p2p1.Install(nodes.Get(0), nodes.Get(1));
 
   Ptr<RateErrorModel> em0 = CreateObject<RateErrorModel>();
   em0->SetAttribute("ErrorRate", DoubleValue(loss0));
   dev0.Get(1)->SetAttribute("ReceiveErrorModel", PointerValue(em0));
 
   Ptr<RateErrorModel> em1 = CreateObject<RateErrorModel>();
   em1->SetAttribute("ErrorRate", DoubleValue(loss1));
   dev1.Get(1)->SetAttribute("ReceiveErrorModel", PointerValue(em1));
 
   InternetStackHelper internet;
   internet.Install(nodes);
 
   Ipv4AddressHelper ipv4;
 
   ipv4.SetBase("10.0.0.0", "255.255.255.0");
   Ipv4InterfaceContainer if0 = ipv4.Assign(dev0);
 
   ipv4.SetBase("10.0.1.0", "255.255.255.0");
   Ipv4InterfaceContainer if1 = ipv4.Assign(dev1);
 
   Ipv4Address senderIp0 = if0.GetAddress(0);
   Ipv4Address recvIp0   = if0.GetAddress(1);
 
   Ipv4Address senderIp1 = if1.GetAddress(0);
   Ipv4Address recvIp1   = if1.GetAddress(1);
 
   // QUIC helper installation
   QuicHelper quic;
   quic.InstallQuic(nodes);
 
   uint16_t port=4433;
 
   // receiver bind to one IP; MPQUIC path manager will accept multiple paths
   Ptr<MpQuic360Receiver> rx = CreateObject<MpQuic360Receiver>();
   rx->Configure(recvIp0, port, tasksCsv, outDir, recoverDir, writeRecovered);
   nodes.Get(1)->AddApplication(rx);
   rx->SetStartTime(Seconds(0.0));
   rx->SetStopTime(Seconds(simTime));
 
   Ptr<MpQuic360Sender> tx = CreateObject<MpQuic360Sender>();
   // bind sender to senderIp0; connect to recvIp0
   // second path is created internally by MPQUIC via additional interface pairs
   tx->Configure(senderIp0, recvIp0, port, tasksCsv, outDir, mode, chunkSize, writeRecovered);
   nodes.Get(0)->AddApplication(tx);
   tx->SetStartTime(Seconds(0.10));
   tx->SetStopTime(Seconds(simTime));
 
   Simulator::Stop(Seconds(simTime));
   Simulator::Run();
   Simulator::Destroy();
 
   NS_LOG_UNCOND("mpquic360-sim DONE mode="<<mode);
   return 0;
 }
 